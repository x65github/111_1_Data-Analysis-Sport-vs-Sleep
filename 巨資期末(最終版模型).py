# -*- coding: utf-8 -*-
"""巨資期末(最終版模型).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Neq8pkz1l8wOt_gcYMSBxRZgXhhQcAZx
"""

import pandas as pd
import csv
import time
import matplotlib.pyplot as plt

"""sleep
---


"""

test = pd.read_csv("levelsmap_concat.csv")
#轉時間
test['start_date_new']=test['startTimeInSeconds'].apply(
    lambda x: time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(x+8*3600)) if not(pd.isnull(x)) else x)
test['end_date_new']=test['endTimeInSeconds'].apply(
    lambda x: time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(x+8*3600)) if not(pd.isnull(x)) else x)
test["new_id"]=test["id"].apply(lambda x:x.replace("levelsmap_",""))
test = test.sort_values(by=['new_id','start_date_new'])
test

#刪掉重複值
data = test.drop_duplicates(subset=['start_date_new','new_id'],keep="first").copy()

#建立一個column，用來放等等判斷式的值
data['sleep'] = None

#判斷睡眠的時段
num=1
l = ['sleep1']
for i in range(1,74063):  
    if data.iloc[i]['start_date_new'] != data.iloc[i-1]['end_date_new']:
        num+=1
        l.append('sleep{}'.format(num))
    else:
        l.append('sleep{}'.format(num))

#把list放進dataframe
data['sleep'] = l
data

import datetime

new=[]
for i in range(0,74063):
  date,daytime=data.iloc[i]['start_date_new'].split(' ')
  daytime=int(daytime.split(':')[0])
  daytime
  if daytime < 12:
    ori=datetime.datetime.strptime(date, '%Y-%m-%d') - datetime.timedelta(days=1)
    new.append(ori)
  else:
    new.append(date)

data['date_new'] = new

#算出持續時間
data['last_time'] = data['endTimeInSeconds']-data['startTimeInSeconds']
data

data2 = data[['sleepLevels','date_new','start_date_new','new_id','last_time','sleep']]

#groupby 算出睡眠時間總和
each_data = data2.groupby(['new_id','sleep']).sum()

#加上日期，方便分析
a=0
datetime = ['2020-09-26']
starttime = ['2020-09-27 05:50:00']
for i in range(1,74063):
    if data2.iloc[i]['sleep'] != data2.iloc[i-1]['sleep']:
      
        datetime.append(data2.iloc[i]['date_new'])
        starttime.append(data2.iloc[i]['start_date_new'])
        a+=1
each_data['date_time'] = datetime
each_data['starttime'] = starttime

#算出深層睡眠時間總和
deep = data2[(data2['sleepLevels'] == 'deep')].groupby(['new_id','sleep','sleepLevels']).sum()
deep.rename(columns={'last_time': 'last_time_deep'}, inplace=True)

#合併睡眠時間和深眠時間，並算比例
merge = pd.merge(each_data,deep,how='outer', on=['new_id','sleep'])
merge['deep_rate'] = merge['last_time_deep']/merge['last_time']
merge['deep_rate'].fillna(value=0,inplace=True)
merge.reset_index('sleep',inplace=True)
merge

merge.nunique()

"""epochs處理
---


"""

import re

#epochs處理
epochs = pd.read_csv("epochs_concat.csv")

#日期換算時區
epochs['date_new']=epochs['startTimeInSeconds'].apply(
    lambda x: time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(x+8*3600)) if not(pd.isnull(x)) else x) 

#epochs
epochs.dropna(axis=0,how='all',subset=['date_new'],inplace=True)
epochs["new_id"]=epochs["id"].apply(lambda x:x.replace("epochs_",""))
epochs = epochs.sort_values(by=['new_id','date_new'])

#只留running和walking
epochs=epochs[(epochs["activityType"]=="WALKING")|(epochs["activityType"]=="RUNNING")]

#算日期
epochs['date_time']=epochs['date_new'].apply(
    lambda x: re.search('\d{4}\-\d{2}\-\d{2}',x).group())
epochs

epochs2=epochs[["new_id","date_time","activeTimeInSeconds","activityType",'date_new']]
epochs2["date_time"] = pd.to_datetime(epochs2["date_time"])
epochs2["date_new"] = pd.to_datetime(epochs2["date_new"])
epochs_final=epochs2.groupby(['new_id','date_time','activityType']).sum()
epochs_final.reset_index(['date_time','activityType'],inplace=True)
epochs_final

epochs_final.nunique()

epochs3 = epochs2.drop_duplicates(subset=['date_time','new_id',"activityType"],keep="last").copy()
epochs3.set_index(['new_id'],inplace=True)
epochs3

epochs3.nunique()

"""合併資料集
---


"""

sleepepochs = pd.merge(epochs_final, merge, how="outer", on=['new_id','date_time'])
mean=sleepepochs['last_time_deep'].mean()
sleepepochs['last_time_deep'].fillna(value=mean,inplace=True)
sleepepochs['activeTimeInSeconds'].fillna(value=0,inplace=True)

sleepepochs['deep_rate']= sleepepochs['last_time_deep']/sleepepochs['last_time']
sleepepochs.dropna(axis=0,how='any',subset=['sleep'],inplace=True)
sleepepochs.reset_index(inplace=True)
sleepepochs

sleepepochs.nunique()

#語萱要用的
'''
sleepepochs1 = pd.merge(epochs3, merge, on=['new_id','date_time'])
sleepepochs1.reset_index(inplace=True)
sleepepochs1.rename(columns={'date_new':'activity_start_time',},inplace=True)
sleepepochs1['if_in_2hr']=sleepepochs1['if_in_2hr'].apply(lambda x: 0 if sleepepochs1['if_in_2hr'])
'''

"""迴歸模型(單項式)－運動時長VS深層睡眠的時長
---


"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

#單項式回歸

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix, accuracy_score

X = sleepepochs.iloc[: ,3].values #運動時長
y = sleepepochs.iloc[: ,-2].values #深層睡眠的時長

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=0)

X_train=X_train.reshape(-1,1)
X_test=X_test.reshape(-1,1)
y_train=y_train.reshape(-1,1)
y_test=y_test.reshape(-1,1)

sc = StandardScaler()
X_train=sc.fit_transform(X_train)
X_test=sc.fit_transform(X_test)

regressor = LinearRegression()
regressor.fit(X_train, y_train)

np.set_printoptions(precision=2)
intercep=regressor.fit(X_train, y_train).intercept_
coef=regressor.fit(X_train, y_train).coef_
print('截距：',intercep)
print('係數：',coef)
print('方程式：y={:.2f}X+{:.7f}'.format(coef[0][0],intercep[0]))
print('訓練準確度：',regressor.score(X_train,y_train))
print('模型準確度：',regressor.score(X_test,y_test))

"""迴歸模型(單項式)－運動時長VS深層睡眠的比率
---
"""

#二項式回歸

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures

X = sleepepochs.iloc[: ,3].values #運動時長
y = sleepepochs.iloc[: ,-1].values #深層睡眠的比率

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=0)
X_train=X_train.reshape(-1,1)
X_test=X_test.reshape(-1,1)
y_train=y_train.reshape(-1,1)
y_test=y_test.reshape(-1,1)

sc = StandardScaler()
X_train=sc.fit_transform(X_train)
X_test=sc.fit_transform(X_test)

poly_reg=PolynomialFeatures(degree=2)
X_poly=poly_reg.fit_transform(X_train)
lin_reg_2=LinearRegression()
lin_reg_2.fit(X_train, y_train)

y_pred = lin_reg_2.predict(X_test)
np.set_printoptions(precision=2)
intercep=lin_reg_2.fit(X_train, y_train).intercept_
coef=lin_reg_2.fit(X_train, y_train).coef_
print('截距：',intercep)
print('係數：',coef)
print('方程式：y={:.2f}X+{:.7f}'.format(coef[0][0],intercep[0]))
print('訓練準確度：',lin_reg_2.score(X_train,y_train))
print('模型準確度：',lin_reg_2.score(X_test,y_test))

"""重新調整資料集－以睡眠階段為主
---


"""

#RUNNING調整
fliter1 = (sleepepochs["activityType"] == "RUNNING")
redo1=sleepepochs[fliter1][['new_id','date_time','activeTimeInSeconds']]
redo1.rename(columns={'activeTimeInSeconds': 'RUNNING'}, inplace=True)
redo1 = redo1.groupby(['new_id','date_time']).sum()
redo1.reset_index(inplace=True)

#WALKING調整
fliter2 = (sleepepochs["activityType"] == "WALKING")
redo2=sleepepochs[fliter2][['new_id','date_time','activeTimeInSeconds']]
redo2.rename(columns={'activeTimeInSeconds': 'Walking'}, inplace=True)
redo2 = redo2.groupby(['new_id','date_time']).sum()
redo2.reset_index(inplace=True)
redo2

#資料合併
epochs_final2 = pd.merge(redo1, redo2, how="outer", on=['new_id','date_time'])
sleepepochs2 = pd.merge(epochs_final2, merge, how="outer", on=['new_id','date_time'])
sleepepochs2['RUNNING'].fillna(value=0,inplace=True)
sleepepochs2['Walking'].fillna(value=0,inplace=True)

mean=sleepepochs2['deep_rate'].mean()
sleepepochs2['deep_rate'].replace(0,mean,inplace=True)
sleepepochs2['last_time_deep']= sleepepochs2['last_time']*sleepepochs2['deep_rate']

sleepepochs2

sleepepochs2.nunique()

"""迴歸模型(多項式)－運動時長VS深層睡眠的時長
---



"""

#單項式回歸

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression

X = sleepepochs2.iloc[: ,2:4].values #運動時長
y = sleepepochs2.iloc[: ,-2].values #深層睡眠的時長

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=0)

sc = StandardScaler()
X_train=sc.fit_transform(X_train)
X_test=sc.fit_transform(X_test)

regressor = LinearRegression()
regressor.fit(X_train, y_train)

y_pred = regressor.predict(X_test)
np.set_printoptions(precision=2)
intercep=regressor.fit(X_train, y_train).intercept_
coef=regressor.fit(X_train, y_train).coef_
print('截距：',intercep)
print('係數：',coef)
print('方程式：y={:.7f} X0+ {:.7f} X1+ {:.2f}'.format(coef[0],coef[1],intercep))
print('訓練準確度：',regressor.score(X_train,y_train))
print('模型準確度：',regressor.score(X_test,y_test))

"""迴歸模型(多項式)－運動時長VS深層睡眠的比率
---


"""

#二項式回歸

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures

X = sleepepochs2.iloc[: ,2:4].values #運動時長
y = sleepepochs2.iloc[: ,-1].values #深層睡眠的比率

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=0)

sc = StandardScaler()
X_train=sc.fit_transform(X_train)
X_test=sc.fit_transform(X_test)

poly_reg=PolynomialFeatures(degree=3)
X_poly=poly_reg.fit_transform(X_train)
lin_reg_2=LinearRegression()
lin_reg_2.fit(X_train, y_train)

y_pred = lin_reg_2.predict(X_test)
np.set_printoptions(precision=2)
intercep=lin_reg_2.fit(X_train, y_train).intercept_
coef=lin_reg_2.fit(X_train, y_train).coef_
print('截距：',intercep)
print('係數：',coef)
print('方程式：y={:.7f} X0+ {:.7f} X1+ {:.2f}'.format(coef[0],coef[1],intercep))
print('訓練準確度：',lin_reg_2.score(X_train,y_train))
print('模型準確度：',lin_reg_2.score(X_test,y_test))

"""隨機森林－將id將受測者資料平均
---
"""

sleepepochs3=sleepepochs2.groupby(['new_id']).mean()
sleepepochs3['deep_rate'] = sleepepochs3['last_time_deep']/sleepepochs3['last_time']
sleepepochs3

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import confusion_matrix, accuracy_score, ConfusionMatrixDisplay


X = sleepepochs3.iloc[: ,:2].values #運動時長
y = sleepepochs3.iloc[: ,-2].values #深層睡眠的時長

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=0)

randomForestModel = RandomForestRegressor(n_estimators=500, criterion = 'mse')
randomForestModel.fit(X_train,y_train)

y_pred = randomForestModel.predict(X_test)
print('訓練準確度：',randomForestModel.score(X_train,y_train))
print('測試準確度：',randomForestModel.score(X_test,y_test))

"""隨機森林－依日期將受測者資料平均
---
"""

sleepepochs4=sleepepochs2.groupby(['date_time']).mean()
sleepepochs4['deep_rate'] = sleepepochs2['last_time_deep']/sleepepochs3['last_time']
sleepepochs4

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import confusion_matrix, accuracy_score, ConfusionMatrixDisplay


X = sleepepochs4.iloc[: ,:2].values #運動時長
y = sleepepochs4.iloc[: ,-2].values #深層睡眠的時長

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=0)

randomForestModel = RandomForestRegressor(n_estimators=500, criterion = 'mse')
randomForestModel.fit(X_train,y_train)

y_pred = randomForestModel.predict(X_test)
print('訓練準確度：',randomForestModel.score(X_train,y_train))
print('測試準確度：',randomForestModel.score(X_test,y_test))

print('特徵重要程度: ',randomForestModel.feature_importances_)
print(y_pred)